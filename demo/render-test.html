<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Visual Render Acceptance Tests - Ghostty WASM</title>
  <style>
    @font-face {
      font-family: "JetBrainsMono NF";
      src: url("https://cdn.jsdelivr.net/gh/ryanoasis/nerd-fonts@latest/patched-fonts/JetBrainsMono/Ligatures/Regular/JetBrainsMonoNerdFont-Regular.ttf") format("truetype");
      font-weight: 400;
      font-style: normal;
      font-display: swap;
    }
    @font-face {
      font-family: "JetBrainsMono NF";
      src: url("https://cdn.jsdelivr.net/gh/ryanoasis/nerd-fonts@latest/patched-fonts/JetBrainsMono/Ligatures/Bold/JetBrainsMonoNerdFont-Bold.ttf") format("truetype");
      font-weight: 700;
      font-style: normal;
      font-display: swap;
    }
    @font-face {
      font-family: "JetBrainsMono NF";
      src: url("https://cdn.jsdelivr.net/gh/ryanoasis/nerd-fonts@latest/patched-fonts/JetBrainsMono/Ligatures/Italic/JetBrainsMonoNerdFont-Italic.ttf") format("truetype");
      font-weight: 400;
      font-style: italic;
      font-display: swap;
    }
    @font-face {
      font-family: "JetBrainsMono NF";
      src: url("https://cdn.jsdelivr.net/gh/ryanoasis/nerd-fonts@latest/patched-fonts/JetBrainsMono/Ligatures/BoldItalic/JetBrainsMonoNerdFont-BoldItalic.ttf") format("truetype");
      font-weight: 700;
      font-style: italic;
      font-display: swap;
    }

    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: system-ui, -apple-system, sans-serif;
      background: #0d1117;
      color: #c9d1d9;
      padding: 20px;
      min-height: 100vh;
    }

    h1 {
      margin-bottom: 10px;
      color: #58a6ff;
    }

    .subtitle {
      color: #8b949e;
      margin-bottom: 20px;
      font-size: 14px;
    }

    .summary {
      background: #161b22;
      border: 1px solid #30363d;
      border-radius: 6px;
      padding: 16px;
      margin-bottom: 20px;
      display: flex;
      align-items: center;
      gap: 20px;
    }

    .summary-stat {
      text-align: center;
    }

    .summary-stat .number {
      font-size: 32px;
      font-weight: bold;
    }

    .summary-stat .label {
      font-size: 12px;
      color: #8b949e;
    }

    .summary-stat.pass .number { color: #3fb950; }
    .summary-stat.fail .number { color: #f85149; }
    .summary-stat.new .number { color: #a371f7; }

    .test-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(500px, 1fr));
      gap: 20px;
    }

    .test-case {
      background: #161b22;
      border: 1px solid #30363d;
      border-radius: 6px;
      overflow: hidden;
    }

    .test-case.pass { border-color: #238636; }
    .test-case.fail { border-color: #f85149; }
    .test-case.new { border-color: #a371f7; }

    .test-header {
      background: #21262d;
      padding: 12px 16px;
      border-bottom: 1px solid #30363d;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }

    .test-header h3 {
      font-size: 14px;
      font-weight: 600;
      color: #c9d1d9;
      margin-bottom: 2px;
    }

    .test-header p {
      font-size: 12px;
      color: #8b949e;
    }

    .test-status {
      padding: 4px 12px;
      border-radius: 12px;
      font-size: 12px;
      font-weight: 600;
    }

    .test-status.pass { background: #238636; color: white; }
    .test-status.fail { background: #f85149; color: white; }
    .test-status.new { background: #a371f7; color: white; }
    .test-status.running { background: #1f6feb; color: white; }

    .test-body {
      padding: 16px;
    }

    .canvas-row {
      display: flex;
      gap: 16px;
      flex-wrap: wrap;
      justify-content: center;
    }

    .canvas-container {
      text-align: center;
    }

    .canvas-container label {
      display: block;
      font-size: 11px;
      color: #8b949e;
      margin-bottom: 4px;
      text-transform: uppercase;
    }

    canvas {
      border: 1px solid #30363d;
      background: #1e1e1e;
    }

    .diff-info {
      margin-top: 12px;
      font-size: 12px;
      color: #8b949e;
      text-align: center;
    }

    .diff-info.significant {
      color: #f85149;
    }

    .test-actions {
      margin-top: 12px;
      display: flex;
      gap: 8px;
      justify-content: center;
    }

    .controls {
      margin-bottom: 20px;
      display: flex;
      gap: 10px;
      flex-wrap: wrap;
    }

    button {
      background: #238636;
      color: white;
      border: none;
      padding: 8px 16px;
      border-radius: 6px;
      cursor: pointer;
      font-size: 14px;
    }

    button:hover {
      background: #2ea043;
    }

    button:disabled {
      background: #30363d;
      cursor: not-allowed;
    }

    button.secondary {
      background: #30363d;
    }

    button.secondary:hover {
      background: #484f58;
    }

    button.small {
      padding: 4px 10px;
      font-size: 12px;
    }

    button.danger {
      background: #da3633;
    }

    button.danger:hover {
      background: #f85149;
    }

    .status {
      margin-top: 20px;
      padding: 10px;
      background: #161b22;
      border-radius: 6px;
      font-family: monospace;
      font-size: 12px;
      max-height: 200px;
      overflow-y: auto;
    }

    .pass { color: #3fb950; }
    .fail { color: #f85149; }
    .info { color: #58a6ff; }
    .warn { color: #d29922; }

    .threshold-control {
      display: flex;
      align-items: center;
      gap: 8px;
      color: #8b949e;
      font-size: 14px;
    }

    .threshold-control input {
      width: 60px;
      padding: 4px 8px;
      border: 1px solid #30363d;
      border-radius: 4px;
      background: #0d1117;
      color: #c9d1d9;
    }

    .instructions {
      background: #161b22;
      border: 1px solid #30363d;
      border-radius: 6px;
      padding: 16px;
      margin-bottom: 20px;
      font-size: 13px;
    }

    .instructions code {
      background: #0d1117;
      padding: 2px 6px;
      border-radius: 4px;
      font-family: monospace;
    }
  </style>
</head>
<body>
  <h1>Visual Render Acceptance Tests</h1>
  <p class="subtitle">Regression tests comparing rendered output against accepted baselines</p>

  <div class="instructions">
    <strong>Usage:</strong> Run with <code>bun run demo</code> or <code>bunx serve .</code> then open this page.<br>
    <strong>New tests:</strong> Click "Accept" to save the current render as the baseline.<br>
    <strong>Failures:</strong> Review the diff, then "Accept" if the change is intentional, or fix the bug.
  </div>

  <div class="summary" id="summary">
    <div class="summary-stat pass">
      <div class="number" id="pass-count">-</div>
      <div class="label">Passed</div>
    </div>
    <div class="summary-stat fail">
      <div class="number" id="fail-count">-</div>
      <div class="label">Failed</div>
    </div>
    <div class="summary-stat new">
      <div class="number" id="new-count">-</div>
      <div class="label">New</div>
    </div>
    <div style="flex: 1;"></div>
    <div class="threshold-control">
      <label>Diff threshold:</label>
      <input type="number" id="threshold" value="0.1" min="0" max="1" step="0.01">
      <span>%</span>
    </div>
  </div>

  <div class="controls">
    <button onclick="runAllTests()" id="run-btn">Run All Tests</button>
    <button class="secondary" onclick="acceptAllNew()">Accept All New</button>
    <button class="secondary" onclick="exportBaselines()">Export Baselines</button>
    <button class="secondary" onclick="importBaselines()">Import Baselines</button>
    <button class="secondary danger" onclick="clearAllBaselines()">Clear Baselines</button>
    <input type="file" id="import-input" accept=".json" style="display: none;" onchange="handleImport(event)">
  </div>

  <div class="test-grid" id="test-grid">
    <!-- Test cases will be dynamically inserted here -->
  </div>

  <div class="status" id="status">
    <div class="info">Ready. Click "Run All Tests" to begin.</div>
  </div>

  <script type="module">
    // Import the renderer from the built dist
    import { CanvasRenderer, DEFAULT_THEME, CellFlags } from '../dist/ghostty-web.js';

    // ========================================================================
    // Storage for baselines (uses IndexedDB for larger images)
    // ========================================================================
    const DB_NAME = 'ghostty-render-tests';
    const DB_VERSION = 1;
    const STORE_NAME = 'baselines';

    let db = null;

    async function initDB() {
      return new Promise((resolve, reject) => {
        const request = indexedDB.open(DB_NAME, DB_VERSION);
        request.onerror = () => reject(request.error);
        request.onsuccess = () => {
          db = request.result;
          resolve(db);
        };
        request.onupgradeneeded = (event) => {
          const db = event.target.result;
          if (!db.objectStoreNames.contains(STORE_NAME)) {
            db.createObjectStore(STORE_NAME, { keyPath: 'id' });
          }
        };
      });
    }

    async function saveBaseline(id, dataUrl) {
      return new Promise((resolve, reject) => {
        const tx = db.transaction(STORE_NAME, 'readwrite');
        const store = tx.objectStore(STORE_NAME);
        store.put({ id, dataUrl, timestamp: Date.now() });
        tx.oncomplete = () => resolve();
        tx.onerror = () => reject(tx.error);
      });
    }

    async function getBaseline(id) {
      return new Promise((resolve, reject) => {
        const tx = db.transaction(STORE_NAME, 'readonly');
        const store = tx.objectStore(STORE_NAME);
        const request = store.get(id);
        request.onsuccess = () => resolve(request.result?.dataUrl || null);
        request.onerror = () => reject(request.error);
      });
    }

    async function getAllBaselines() {
      return new Promise((resolve, reject) => {
        const tx = db.transaction(STORE_NAME, 'readonly');
        const store = tx.objectStore(STORE_NAME);
        const request = store.getAll();
        request.onsuccess = () => resolve(request.result || []);
        request.onerror = () => reject(request.error);
      });
    }

    async function clearBaselines() {
      return new Promise((resolve, reject) => {
        const tx = db.transaction(STORE_NAME, 'readwrite');
        const store = tx.objectStore(STORE_NAME);
        store.clear();
        tx.oncomplete = () => resolve();
        tx.onerror = () => reject(tx.error);
      });
    }

    // ========================================================================
    // Pixel comparison (simplified pixelmatch algorithm)
    // ========================================================================
    function compareImages(canvas1, canvas2, diffCanvas) {
      const ctx1 = canvas1.getContext('2d');
      const ctx2 = canvas2.getContext('2d');
      const ctxDiff = diffCanvas.getContext('2d');

      const width = Math.max(canvas1.width, canvas2.width);
      const height = Math.max(canvas1.height, canvas2.height);

      // Resize diff canvas
      diffCanvas.width = width;
      diffCanvas.height = height;

      // Get image data
      const img1 = ctx1.getImageData(0, 0, canvas1.width, canvas1.height);
      const img2 = ctx2.getImageData(0, 0, canvas2.width, canvas2.height);
      const diff = ctxDiff.createImageData(width, height);

      let diffPixels = 0;
      const totalPixels = width * height;

      for (let y = 0; y < height; y++) {
        for (let x = 0; x < width; x++) {
          const idx = (y * width + x) * 4;

          // Get pixel from each image (black if out of bounds)
          const r1 = x < canvas1.width && y < canvas1.height ? img1.data[(y * canvas1.width + x) * 4] : 0;
          const g1 = x < canvas1.width && y < canvas1.height ? img1.data[(y * canvas1.width + x) * 4 + 1] : 0;
          const b1 = x < canvas1.width && y < canvas1.height ? img1.data[(y * canvas1.width + x) * 4 + 2] : 0;

          const r2 = x < canvas2.width && y < canvas2.height ? img2.data[(y * canvas2.width + x) * 4] : 0;
          const g2 = x < canvas2.width && y < canvas2.height ? img2.data[(y * canvas2.width + x) * 4 + 1] : 0;
          const b2 = x < canvas2.width && y < canvas2.height ? img2.data[(y * canvas2.width + x) * 4 + 2] : 0;

          // Simple color difference (Manhattan distance)
          const colorDiff = Math.abs(r1 - r2) + Math.abs(g1 - g2) + Math.abs(b1 - b2);

          if (colorDiff > 10) { // Threshold for "different"
            // Red for difference
            diff.data[idx] = 255;
            diff.data[idx + 1] = 0;
            diff.data[idx + 2] = 0;
            diff.data[idx + 3] = 255;
            diffPixels++;
          } else {
            // Dim copy of original
            diff.data[idx] = Math.floor(r1 * 0.3);
            diff.data[idx + 1] = Math.floor(g1 * 0.3);
            diff.data[idx + 2] = Math.floor(b1 * 0.3);
            diff.data[idx + 3] = 255;
          }
        }
      }

      ctxDiff.putImageData(diff, 0, 0);

      return {
        diffPixels,
        totalPixels,
        diffPercent: (diffPixels / totalPixels) * 100
      };
    }

    // ========================================================================
    // Default colors
    // ========================================================================
    const DEFAULT_FG = { r: 212, g: 212, b: 212 };
    const DEFAULT_BG = { r: 0, g: 0, b: 0 };

    // ========================================================================
    // Helper: Create a mock cell
    // ========================================================================
    function createCell(char, options = {}) {
      const codepoint = char.codePointAt(0) || 32;
      return {
        codepoint,
        fg_r: options.fg?.r ?? DEFAULT_FG.r,
        fg_g: options.fg?.g ?? DEFAULT_FG.g,
        fg_b: options.fg?.b ?? DEFAULT_FG.b,
        bg_r: options.bg?.r ?? DEFAULT_BG.r,
        bg_g: options.bg?.g ?? DEFAULT_BG.g,
        bg_b: options.bg?.b ?? DEFAULT_BG.b,
        flags: options.flags ?? 0,
        width: options.width ?? 1,
        hyperlink_id: options.hyperlink_id ?? 0,
        grapheme_len: options.grapheme_len ?? 0,
      };
    }

    // ========================================================================
    // Helper: Create a line of cells from text
    // ========================================================================
    function createLine(text, cols, options = {}) {
      const line = [];
      for (let i = 0; i < cols; i++) {
        const char = text[i] || ' ';
        line.push(createCell(char, options));
      }
      return line;
    }

    // ========================================================================
    // Helper: Create a mock buffer for rendering
    // ========================================================================
    function createMockBuffer(lines, cursor = { x: 0, y: 0, visible: false }) {
      const rows = lines.length;
      const cols = lines[0]?.length ?? 80;

      return {
        getLine(y) { return lines[y] || null; },
        getCursor() { return cursor; },
        getDimensions() { return { cols, rows }; },
        isRowDirty() { return true; },
        needsFullRedraw() { return false; },
        clearDirty() {},
      };
    }

    // ========================================================================
    // Test Case Registry
    // ========================================================================
    const testCases = [];
    const testResults = new Map();

    function registerTest(id, name, description, renderFn) {
      testCases.push({ id, name, description, renderFn });
    }

    // ========================================================================
    // TEST DEFINITIONS
    // ========================================================================

    registerTest('basic-text', 'Basic Text Rendering', 'Simple ASCII text with default colors', (canvas) => {
      const renderer = new CanvasRenderer(canvas, {
        fontSize: 14,
        fontFamily: '"JetBrainsMono NF", Monaco, monospace',
      });
      const lines = [
        createLine('Hello, World!', 20),
        createLine('ABCDEFGHIJKLMNOP', 20),
        createLine('0123456789!@#$%^', 20),
      ];
      renderer.render(createMockBuffer(lines), true);
    });

    registerTest('text-styles', 'Text Styles', 'Bold, Italic, Underline, Strikethrough, Faint', (canvas) => {
      const renderer = new CanvasRenderer(canvas, {
        fontSize: 14,
        fontFamily: '"JetBrainsMono NF", Monaco, monospace',
      });
      const cols = 25;
      const lines = [
        createLine('Normal text here    ', cols),
        createLine('Bold text here      ', cols, { flags: CellFlags.BOLD }),
        createLine('Italic text here    ', cols, { flags: CellFlags.ITALIC }),
        createLine('Underline text here ', cols, { flags: CellFlags.UNDERLINE }),
        createLine('Strikethrough text  ', cols, { flags: CellFlags.STRIKETHROUGH }),
        createLine('Faint/Dim text here ', cols, { flags: CellFlags.FAINT }),
        createLine('Bold+Italic combo   ', cols, { flags: CellFlags.BOLD | CellFlags.ITALIC }),
        createLine('Bold+Underline combo', cols, { flags: CellFlags.BOLD | CellFlags.UNDERLINE }),
      ];
      renderer.render(createMockBuffer(lines), true);
    });

    registerTest('inverse-video', 'Inverse Video', 'Foreground and background colors swapped', (canvas) => {
      const renderer = new CanvasRenderer(canvas, {
        fontSize: 14,
        fontFamily: '"JetBrainsMono NF", Monaco, monospace',
      });
      const cols = 25;
      const lines = [
        createLine('Normal text         ', cols),
        createLine('Inverse video text  ', cols, { flags: CellFlags.INVERSE }),
        createLine('Normal again        ', cols),
        (() => {
          const line = [];
          const text = 'Mixed: inv | normal  ';
          for (let i = 0; i < cols; i++) {
            const isInverse = i >= 7 && i < 10;
            line.push(createCell(text[i] || ' ', { flags: isInverse ? CellFlags.INVERSE : 0 }));
          }
          return line;
        })(),
      ];
      renderer.render(createMockBuffer(lines), true);
    });

    registerTest('ansi-colors', 'ANSI 16 Colors', 'Standard ANSI color palette', (canvas) => {
      const renderer = new CanvasRenderer(canvas, {
        fontSize: 14,
        fontFamily: '"JetBrainsMono NF", Monaco, monospace',
      });
      const ansiColors = [
        { r: 0, g: 0, b: 0 }, { r: 205, g: 49, b: 49 }, { r: 13, g: 188, b: 121 }, { r: 229, g: 229, b: 16 },
        { r: 36, g: 114, b: 200 }, { r: 188, g: 63, b: 188 }, { r: 17, g: 168, b: 205 }, { r: 229, g: 229, b: 229 },
        { r: 102, g: 102, b: 102 }, { r: 241, g: 76, b: 76 }, { r: 35, g: 209, b: 139 }, { r: 245, g: 245, b: 67 },
        { r: 59, g: 142, b: 234 }, { r: 214, g: 112, b: 214 }, { r: 41, g: 184, b: 219 }, { r: 255, g: 255, b: 255 },
      ];
      const cols = 32;
      const lines = [];

      // Normal colors foreground
      const row1 = [];
      for (let i = 0; i < 8; i++) {
        for (const char of ` ${i} `) row1.push(createCell(char, { fg: ansiColors[i] }));
        row1.push(createCell(' '));
      }
      while (row1.length < cols) row1.push(createCell(' '));
      lines.push(row1.slice(0, cols));

      // Normal colors background
      const row2 = [];
      for (let i = 0; i < 8; i++) {
        for (const char of '   ') row2.push(createCell(char, { bg: ansiColors[i], fg: { r: 255, g: 255, b: 255 } }));
        row2.push(createCell(' '));
      }
      while (row2.length < cols) row2.push(createCell(' '));
      lines.push(row2.slice(0, cols));

      lines.push(createLine('', cols));

      // Bright colors
      const row3 = [];
      for (let i = 8; i < 16; i++) {
        for (const char of `${i.toString().padStart(2)}`) row3.push(createCell(char, { fg: ansiColors[i] }));
        row3.push(createCell(' ')); row3.push(createCell(' '));
      }
      while (row3.length < cols) row3.push(createCell(' '));
      lines.push(row3.slice(0, cols));

      const row4 = [];
      for (let i = 8; i < 16; i++) {
        for (const char of '   ') row4.push(createCell(char, { bg: ansiColors[i], fg: { r: 0, g: 0, b: 0 } }));
        row4.push(createCell(' '));
      }
      while (row4.length < cols) row4.push(createCell(' '));
      lines.push(row4.slice(0, cols));

      renderer.render(createMockBuffer(lines), true);
    });

    registerTest('rgb-colors', 'RGB Colors', 'True color (24-bit) foreground and background', (canvas) => {
      const renderer = new CanvasRenderer(canvas, {
        fontSize: 14,
        fontFamily: '"JetBrainsMono NF", Monaco, monospace',
      });
      const cols = 30;
      const lines = [];

      // Gradient row
      const gradient = [];
      for (let i = 0; i < cols; i++) {
        const r = Math.floor((i / cols) * 255);
        const g = Math.floor(((cols - i) / cols) * 255);
        gradient.push(createCell('\u2588', { fg: { r, g, b: 128 } }));
      }
      lines.push(gradient);

      // Background gradient
      const bgGradient = [];
      for (let i = 0; i < cols; i++) {
        const r = Math.floor((i / cols) * 255);
        const b = Math.floor(((cols - i) / cols) * 255);
        bgGradient.push(createCell(' ', { bg: { r, g: 0, b } }));
      }
      lines.push(bgGradient);

      lines.push(createLine('', cols));
      lines.push(createLine('Custom RGB colors:', cols, { fg: { r: 255, g: 165, b: 0 } }));
      lines.push(createLine('Pink background', cols, { fg: { r: 0, g: 0, b: 0 }, bg: { r: 255, g: 182, b: 193 } }));

      renderer.render(createMockBuffer(lines), true);
    });

    registerTest('cursor-block', 'Cursor: Block', 'Block cursor style', (canvas) => {
      const renderer = new CanvasRenderer(canvas, {
        fontSize: 14,
        fontFamily: '"JetBrainsMono NF", Monaco, monospace',
        cursorStyle: 'block',
      });
      const cols = 20;
      const lines = [createLine('Block cursor here:', cols), createLine('Text with cursor', cols)];
      renderer.render(createMockBuffer(lines, { x: 5, y: 1, visible: true }), true);
    });

    registerTest('cursor-underline', 'Cursor: Underline', 'Underline cursor style', (canvas) => {
      const renderer = new CanvasRenderer(canvas, {
        fontSize: 14,
        fontFamily: '"JetBrainsMono NF", Monaco, monospace',
        cursorStyle: 'underline',
      });
      const cols = 20;
      const lines = [createLine('Underline cursor:', cols), createLine('Text with cursor', cols)];
      renderer.render(createMockBuffer(lines, { x: 5, y: 1, visible: true }), true);
    });

    registerTest('cursor-bar', 'Cursor: Bar', 'Bar (I-beam) cursor style', (canvas) => {
      const renderer = new CanvasRenderer(canvas, {
        fontSize: 14,
        fontFamily: '"JetBrainsMono NF", Monaco, monospace',
        cursorStyle: 'bar',
      });
      const cols = 20;
      const lines = [createLine('Bar cursor here:', cols), createLine('Text with cursor', cols)];
      renderer.render(createMockBuffer(lines, { x: 5, y: 1, visible: true }), true);
    });

    registerTest('wide-chars', 'Wide Characters', 'CJK characters (width=2)', (canvas) => {
      const renderer = new CanvasRenderer(canvas, {
        fontSize: 14,
        fontFamily: '"JetBrainsMono NF", Monaco, monospace',
      });
      const cols = 30;
      const lines = [];

      // CJK characters
      for (const [text, label] of [['\u4E2D\u6587', 'Chinese'], ['\u65E5\u672C\u8A9E', 'Japanese'], ['\uD55C\uAE00', 'Korean']]) {
        const line = [];
        for (const char of text) {
          line.push(createCell(char, { width: 2 }));
          line.push(createCell('', { width: 0 }));
        }
        while (line.length < cols) line.push(createCell(' '));
        lines.push(line);
      }

      // Mixed
      const mixedLine = [];
      for (const part of ['AB', '\u4E2D', 'CD', '\u6587', 'EF']) {
        for (const char of part) {
          const isWide = char.charCodeAt(0) > 0x2E7F;
          mixedLine.push(createCell(char, { width: isWide ? 2 : 1 }));
          if (isWide) mixedLine.push(createCell('', { width: 0 }));
        }
      }
      while (mixedLine.length < cols) mixedLine.push(createCell(' '));
      lines.push(mixedLine.slice(0, cols));

      renderer.render(createMockBuffer(lines), true);
    });

    registerTest('selection', 'Selection Highlighting', 'Multi-line selection', (canvas) => {
      const renderer = new CanvasRenderer(canvas, {
        fontSize: 14,
        fontFamily: '"JetBrainsMono NF", Monaco, monospace',
      });
      const cols = 30;
      const lines = [
        createLine('Line 1: No selection here', cols),
        createLine('Line 2: Selection starts', cols),
        createLine('Line 3: Middle of select', cols),
        createLine('Line 4: Selection ends', cols),
        createLine('Line 5: No selection here', cols),
      ];

      const selectionManager = {
        hasSelection: () => true,
        getSelectionCoords: () => ({ startCol: 8, startRow: 1, endCol: 20, endRow: 3 }),
        getDirtySelectionRows: () => new Set(),
        clearDirtySelectionRows: () => {},
      };

      renderer.setSelectionManager(selectionManager);
      renderer.render(createMockBuffer(lines), true);
    });

    registerTest('invisible-text', 'Invisible Text', 'INVISIBLE flag hides text', (canvas) => {
      const renderer = new CanvasRenderer(canvas, {
        fontSize: 14,
        fontFamily: '"JetBrainsMono NF", Monaco, monospace',
      });
      const cols = 30;
      const lines = [
        createLine('Visible text here', cols),
        createLine('HIDDEN PASSWORD HERE', cols, { flags: CellFlags.INVISIBLE }),
        createLine('More visible text', cols),
      ];
      renderer.render(createMockBuffer(lines), true);
    });

    registerTest('hyperlink', 'Hyperlink Hover', 'OSC8 hyperlink underline', (canvas) => {
      const renderer = new CanvasRenderer(canvas, {
        fontSize: 14,
        fontFamily: '"JetBrainsMono NF", Monaco, monospace',
      });
      const cols = 35;
      const lines = [];

      lines.push(createLine('No link here', cols));

      const linkLine = [];
      for (const char of 'Click: ') linkLine.push(createCell(char));
      for (const char of 'https://example.com') linkLine.push(createCell(char, { hyperlink_id: 1 }));
      while (linkLine.length < cols) linkLine.push(createCell(' '));
      lines.push(linkLine);

      const link2Line = [];
      for (const char of 'Also: ') link2Line.push(createCell(char));
      for (const char of 'mailto:test@test.com') link2Line.push(createCell(char, { hyperlink_id: 2 }));
      while (link2Line.length < cols) link2Line.push(createCell(' '));
      lines.push(link2Line);

      renderer.setHoveredHyperlinkId(1);
      renderer.render(createMockBuffer(lines), true);
    });

    registerTest('combined-styles', 'Combined Styles', 'Multiple styles on same text', (canvas) => {
      const renderer = new CanvasRenderer(canvas, {
        fontSize: 14,
        fontFamily: '"JetBrainsMono NF", Monaco, monospace',
      });
      const cols = 30;
      const lines = [
        createLine('Bold + Italic + Underline:', cols),
        createLine('Combined styling test', cols, { flags: CellFlags.BOLD | CellFlags.ITALIC | CellFlags.UNDERLINE }),
        createLine('', cols),
        createLine('Faint + Strikethrough:', cols),
        createLine('Deleted faint text', cols, { flags: CellFlags.FAINT | CellFlags.STRIKETHROUGH }),
        createLine('', cols),
        createLine('Bold + Colored:', cols),
        createLine('Bold red text', cols, { flags: CellFlags.BOLD, fg: { r: 255, g: 85, b: 85 } }),
      ];
      renderer.render(createMockBuffer(lines), true);
    });

    registerTest('cell-backgrounds', 'Cell Backgrounds', 'Individual cell background colors', (canvas) => {
      const renderer = new CanvasRenderer(canvas, {
        fontSize: 14,
        fontFamily: '"JetBrainsMono NF", Monaco, monospace',
      });
      const cols = 35;
      const lines = [];

      // Checkerboard
      const checkerboard = [];
      for (let i = 0; i < cols; i++) {
        checkerboard.push(createCell(' ', {
          bg: i % 2 === 0 ? { r: 40, g: 40, b: 40 } : { r: 60, g: 60, b: 60 }
        }));
      }
      lines.push(checkerboard);

      // Color blocks
      const colorBlocks = [];
      const colors = [
        { bg: { r: 255, g: 0, b: 0 }, fg: { r: 255, g: 255, b: 255 } },
        { bg: { r: 0, g: 255, b: 0 }, fg: { r: 0, g: 0, b: 0 } },
        { bg: { r: 0, g: 0, b: 255 }, fg: { r: 255, g: 255, b: 255 } },
        { bg: { r: 255, g: 255, b: 0 }, fg: { r: 0, g: 0, b: 0 } },
        { bg: { r: 255, g: 0, b: 255 }, fg: { r: 0, g: 0, b: 0 } },
      ];
      const labels = ['RED', 'GRN', 'BLU', 'YEL', 'MAG'];
      for (let i = 0; i < colors.length; i++) {
        for (const char of ` ${labels[i]} `) colorBlocks.push(createCell(char, colors[i]));
        colorBlocks.push(createCell(' '));
      }
      while (colorBlocks.length < cols) colorBlocks.push(createCell(' '));
      lines.push(colorBlocks.slice(0, cols));

      lines.push(createLine('', cols));
      lines.push(createLine('Syntax highlighting demo:', cols));

      // Syntax
      const syntaxLine = [];
      const parts = [
        { text: 'const ', fg: { r: 86, g: 156, b: 214 } },
        { text: 'x', fg: { r: 156, g: 220, b: 254 } },
        { text: ' = ', fg: { r: 212, g: 212, b: 212 } },
        { text: '"hello"', fg: { r: 206, g: 145, b: 120 } },
        { text: ';', fg: { r: 212, g: 212, b: 212 } },
      ];
      for (const part of parts) {
        for (const char of part.text) syntaxLine.push(createCell(char, { fg: part.fg }));
      }
      while (syntaxLine.length < cols) syntaxLine.push(createCell(' '));
      lines.push(syntaxLine.slice(0, cols));

      renderer.render(createMockBuffer(lines), true);
    });

    // ========================================================================
    // UI Setup
    // ========================================================================

    function createTestUI() {
      const grid = document.getElementById('test-grid');
      grid.innerHTML = '';

      for (const test of testCases) {
        const testCase = document.createElement('div');
        testCase.className = 'test-case';
        testCase.id = `test-${test.id}`;

        testCase.innerHTML = `
          <div class="test-header">
            <div>
              <h3>${test.name}</h3>
              <p>${test.description}</p>
            </div>
            <span class="test-status" id="status-${test.id}">Pending</span>
          </div>
          <div class="test-body">
            <div class="canvas-row">
              <div class="canvas-container">
                <label>Current</label>
                <canvas id="canvas-${test.id}" width="400" height="200"></canvas>
              </div>
              <div class="canvas-container">
                <label>Baseline</label>
                <canvas id="baseline-${test.id}" width="400" height="200"></canvas>
              </div>
              <div class="canvas-container">
                <label>Diff</label>
                <canvas id="diff-${test.id}" width="400" height="200"></canvas>
              </div>
            </div>
            <div class="diff-info" id="diff-info-${test.id}"></div>
            <div class="test-actions">
              <button class="small secondary" onclick="acceptBaseline('${test.id}')">Accept Current</button>
            </div>
          </div>
        `;

        grid.appendChild(testCase);
      }
    }

    function updateSummary() {
      let pass = 0, fail = 0, newCount = 0;
      for (const result of testResults.values()) {
        if (result === 'pass') pass++;
        else if (result === 'fail') fail++;
        else if (result === 'new') newCount++;
      }
      document.getElementById('pass-count').textContent = pass;
      document.getElementById('fail-count').textContent = fail;
      document.getElementById('new-count').textContent = newCount;
    }

    function logStatus(message, type = 'info') {
      const status = document.getElementById('status');
      const div = document.createElement('div');
      div.className = type;
      div.textContent = `[${new Date().toLocaleTimeString()}] ${message}`;
      status.appendChild(div);
      status.scrollTop = status.scrollHeight;
    }

    async function loadBaselineImage(id) {
      const dataUrl = await getBaseline(id);
      if (!dataUrl) return null;

      return new Promise((resolve) => {
        const img = new Image();
        img.onload = () => resolve(img);
        img.onerror = () => resolve(null);
        img.src = dataUrl;
      });
    }

    async function runTest(test) {
      const statusEl = document.getElementById(`status-${test.id}`);
      const testCase = document.getElementById(`test-${test.id}`);
      const canvas = document.getElementById(`canvas-${test.id}`);
      const baselineCanvas = document.getElementById(`baseline-${test.id}`);
      const diffCanvas = document.getElementById(`diff-${test.id}`);
      const diffInfo = document.getElementById(`diff-info-${test.id}`);

      statusEl.textContent = 'Running';
      statusEl.className = 'test-status running';
      testCase.className = 'test-case';

      // Reset canvas
      canvas.width = 400;
      canvas.height = 200;

      try {
        // Render current
        test.renderFn(canvas);

        // Load baseline
        const baselineImg = await loadBaselineImage(test.id);

        if (!baselineImg) {
          // No baseline - new test
          statusEl.textContent = 'New';
          statusEl.className = 'test-status new';
          testCase.className = 'test-case new';
          diffInfo.textContent = 'No baseline. Click "Accept Current" to create one.';
          diffInfo.className = 'diff-info';
          testResults.set(test.id, 'new');
          logStatus(`NEW: ${test.name} - no baseline exists`, 'warn');

          // Clear baseline and diff canvases
          const baselineCtx = baselineCanvas.getContext('2d');
          baselineCtx.fillStyle = '#1e1e1e';
          baselineCtx.fillRect(0, 0, baselineCanvas.width, baselineCanvas.height);
          baselineCtx.fillStyle = '#8b949e';
          baselineCtx.font = '14px sans-serif';
          baselineCtx.textAlign = 'center';
          baselineCtx.fillText('No baseline', baselineCanvas.width / 2, baselineCanvas.height / 2);

          const diffCtx = diffCanvas.getContext('2d');
          diffCtx.fillStyle = '#1e1e1e';
          diffCtx.fillRect(0, 0, diffCanvas.width, diffCanvas.height);

          return 'new';
        }

        // Draw baseline
        baselineCanvas.width = baselineImg.width;
        baselineCanvas.height = baselineImg.height;
        const baselineCtx = baselineCanvas.getContext('2d');
        baselineCtx.drawImage(baselineImg, 0, 0);

        // Compare
        const threshold = parseFloat(document.getElementById('threshold').value) || 0.1;
        const result = compareImages(canvas, baselineCanvas, diffCanvas);

        if (result.diffPercent <= threshold) {
          statusEl.textContent = 'Pass';
          statusEl.className = 'test-status pass';
          testCase.className = 'test-case pass';
          diffInfo.textContent = `${result.diffPixels} different pixels (${result.diffPercent.toFixed(3)}%)`;
          diffInfo.className = 'diff-info';
          testResults.set(test.id, 'pass');
          logStatus(`PASS: ${test.name}`, 'pass');
          return 'pass';
        } else {
          statusEl.textContent = 'Fail';
          statusEl.className = 'test-status fail';
          testCase.className = 'test-case fail';
          diffInfo.textContent = `${result.diffPixels} different pixels (${result.diffPercent.toFixed(3)}%) exceeds threshold ${threshold}%`;
          diffInfo.className = 'diff-info significant';
          testResults.set(test.id, 'fail');
          logStatus(`FAIL: ${test.name} - ${result.diffPercent.toFixed(3)}% diff`, 'fail');
          return 'fail';
        }
      } catch (e) {
        statusEl.textContent = 'Error';
        statusEl.className = 'test-status fail';
        testCase.className = 'test-case fail';
        diffInfo.textContent = `Error: ${e.message}`;
        testResults.set(test.id, 'fail');
        logStatus(`ERROR: ${test.name} - ${e.message}`, 'fail');
        console.error(test.name, e);
        return 'fail';
      }
    }

    async function runAllTests() {
      document.getElementById('run-btn').disabled = true;
      logStatus('Starting acceptance test suite...', 'info');
      testResults.clear();

      // Wait for fonts
      try {
        await document.fonts.load('14px "JetBrainsMono NF"');
        await document.fonts.load('bold 14px "JetBrainsMono NF"');
        await document.fonts.load('italic 14px "JetBrainsMono NF"');
        logStatus('Fonts loaded', 'info');
      } catch (e) {
        logStatus('Font loading warning: ' + e.message, 'warn');
      }

      // Run each test
      for (const test of testCases) {
        await runTest(test);
        updateSummary();
      }

      // Final summary
      const pass = [...testResults.values()].filter(r => r === 'pass').length;
      const fail = [...testResults.values()].filter(r => r === 'fail').length;
      const newCount = [...testResults.values()].filter(r => r === 'new').length;

      logStatus(`Complete: ${pass} passed, ${fail} failed, ${newCount} new`, pass === testCases.length ? 'pass' : (fail > 0 ? 'fail' : 'warn'));
      document.getElementById('run-btn').disabled = false;
    }

    async function acceptBaseline(id) {
      const canvas = document.getElementById(`canvas-${id}`);
      const dataUrl = canvas.toDataURL('image/png');
      await saveBaseline(id, dataUrl);
      logStatus(`Accepted baseline for: ${id}`, 'pass');

      // Re-run this test
      const test = testCases.find(t => t.id === id);
      if (test) {
        await runTest(test);
        updateSummary();
      }
    }

    async function acceptAllNew() {
      for (const [id, result] of testResults) {
        if (result === 'new') {
          await acceptBaseline(id);
        }
      }
    }

    async function exportBaselines() {
      const baselines = await getAllBaselines();
      const data = {};
      for (const b of baselines) {
        data[b.id] = b.dataUrl;
      }
      const json = JSON.stringify(data, null, 2);
      const blob = new Blob([json], { type: 'application/json' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = 'render-test-baselines.json';
      a.click();
      URL.revokeObjectURL(url);
      logStatus('Exported baselines to render-test-baselines.json', 'info');
    }

    function importBaselines() {
      document.getElementById('import-input').click();
    }

    async function handleImport(event) {
      const file = event.target.files[0];
      if (!file) return;

      try {
        const text = await file.text();
        const data = JSON.parse(text);
        let count = 0;
        for (const [id, dataUrl] of Object.entries(data)) {
          await saveBaseline(id, dataUrl);
          count++;
        }
        logStatus(`Imported ${count} baselines`, 'pass');
        // Re-run tests
        await runAllTests();
      } catch (e) {
        logStatus(`Import failed: ${e.message}`, 'fail');
      }
    }

    async function clearAllBaselines() {
      if (!confirm('Clear all baselines? This cannot be undone.')) return;
      await clearBaselines();
      logStatus('Cleared all baselines', 'warn');
      await runAllTests();
    }

    // Initialize
    async function init() {
      await initDB();
      createTestUI();
      logStatus('Ready. Click "Run All Tests" to begin.', 'info');

      // Auto-run after fonts ready
      document.fonts.ready.then(() => {
        setTimeout(runAllTests, 200);
      });
    }

    init();

    // Export for manual control
    window.runAllTests = runAllTests;
    window.acceptBaseline = acceptBaseline;
    window.acceptAllNew = acceptAllNew;
    window.exportBaselines = exportBaselines;
    window.importBaselines = importBaselines;
    window.handleImport = handleImport;
    window.clearAllBaselines = clearAllBaselines;
  </script>
</body>
</html>
