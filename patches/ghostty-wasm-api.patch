diff --git a/.gitignore b/.gitignore
index e451b171a..89c623d8b 100644
--- a/.gitignore
+++ b/.gitignore
@@ -23,3 +23,4 @@ glad.zip
 /ghostty.qcow2
 
 vgcore.*
+node_modules/
diff --git a/include/ghostty/vt.h b/include/ghostty/vt.h
index 4f8fef88e..ca9fb1d4d 100644
--- a/include/ghostty/vt.h
+++ b/include/ghostty/vt.h
@@ -28,6 +28,7 @@
  * @section groups_sec API Reference
  *
  * The API is organized into the following groups:
+ * - @ref terminal "Terminal Emulator" - Complete terminal emulator with VT parsing
  * - @ref key "Key Encoding" - Encode key events into terminal sequences
  * - @ref osc "OSC Parser" - Parse OSC (Operating System Command) sequences
  * - @ref sgr "SGR Parser" - Parse SGR (Select Graphic Rendition) sequences
@@ -74,6 +75,7 @@ extern "C" {
 
 #include <ghostty/vt/result.h>
 #include <ghostty/vt/allocator.h>
+#include <ghostty/vt/terminal.h>
 #include <ghostty/vt/osc.h>
 #include <ghostty/vt/sgr.h>
 #include <ghostty/vt/key.h>
diff --git a/include/ghostty/vt/terminal.h b/include/ghostty/vt/terminal.h
new file mode 100644
index 000000000..e371164b6
--- /dev/null
+++ b/include/ghostty/vt/terminal.h
@@ -0,0 +1,192 @@
+/**
+ * @file terminal.h
+ *
+ * Minimal, high-performance terminal emulator API for WASM.
+ *
+ * The key optimization is the RenderState API which provides a pre-computed
+ * snapshot of all render data in a single update call, avoiding multiple
+ * WASM boundary crossings.
+ *
+ * Basic usage:
+ *   1. Create terminal: ghostty_terminal_new(80, 24)
+ *   2. Write data: ghostty_terminal_write(term, data, len)
+ *   3. Each frame:
+ *      - ghostty_render_state_update(term)
+ *      - ghostty_render_state_get_viewport(term, buffer, size)
+ *      - Render the buffer
+ *      - ghostty_render_state_mark_clean(term)
+ *   4. Free: ghostty_terminal_free(term)
+ */
+
+#ifndef GHOSTTY_VT_TERMINAL_H
+#define GHOSTTY_VT_TERMINAL_H
+
+#include <stdbool.h>
+#include <stddef.h>
+#include <stdint.h>
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/** Opaque terminal handle */
+typedef void* GhosttyTerminal;
+
+/**
+ * Terminal configuration.
+ * All color values use 0xRRGGBB format. A value of 0 means "use default".
+ */
+typedef struct {
+    /** Maximum scrollback lines (0 = unlimited) */
+    uint32_t scrollback_limit;
+    /** Default foreground color (0xRRGGBB, 0 = default) */
+    uint32_t fg_color;
+    /** Default background color (0xRRGGBB, 0 = default) */
+    uint32_t bg_color;
+    /** Cursor color (0xRRGGBB, 0 = default) */
+    uint32_t cursor_color;
+    /** ANSI color palette (16 colors, 0xRRGGBB format, 0 = default) */
+    uint32_t palette[16];
+} GhosttyTerminalConfig;
+
+/** Cell structure - 16 bytes, pre-resolved colors */
+typedef struct {
+    uint32_t codepoint;
+    uint8_t fg_r, fg_g, fg_b;
+    uint8_t bg_r, bg_g, bg_b;
+    uint8_t flags;
+    uint8_t width;
+    uint16_t hyperlink_id;
+    uint16_t _pad;
+} GhosttyCell;
+
+/** Cell flags */
+#define GHOSTTY_CELL_BOLD          (1 << 0)
+#define GHOSTTY_CELL_ITALIC        (1 << 1)
+#define GHOSTTY_CELL_UNDERLINE     (1 << 2)
+#define GHOSTTY_CELL_STRIKETHROUGH (1 << 3)
+#define GHOSTTY_CELL_INVERSE       (1 << 4)
+#define GHOSTTY_CELL_INVISIBLE     (1 << 5)
+#define GHOSTTY_CELL_BLINK         (1 << 6)
+#define GHOSTTY_CELL_FAINT         (1 << 7)
+
+/** Dirty state */
+typedef enum {
+    GHOSTTY_DIRTY_NONE = 0,
+    GHOSTTY_DIRTY_PARTIAL = 1,
+    GHOSTTY_DIRTY_FULL = 2
+} GhosttyDirty;
+
+/* ============================================================================
+ * Lifecycle
+ * ========================================================================= */
+
+/** Create a new terminal with default settings */
+GhosttyTerminal ghostty_terminal_new(int cols, int rows);
+
+/**
+ * Create a new terminal with custom configuration.
+ * @param cols Number of columns
+ * @param rows Number of rows
+ * @param config Configuration options (NULL = use defaults)
+ * @return Terminal handle, or NULL on failure
+ */
+GhosttyTerminal ghostty_terminal_new_with_config(
+    int cols,
+    int rows,
+    const GhosttyTerminalConfig* config
+);
+
+/** Free a terminal */
+void ghostty_terminal_free(GhosttyTerminal term);
+
+/** Resize terminal */
+void ghostty_terminal_resize(GhosttyTerminal term, int cols, int rows);
+
+/** Write data to terminal (parses VT sequences) */
+void ghostty_terminal_write(GhosttyTerminal term, const uint8_t* data, size_t len);
+
+/* ============================================================================
+ * RenderState API - High-performance rendering
+ * ========================================================================= */
+
+/** Update render state from terminal. Call once per frame. */
+GhosttyDirty ghostty_render_state_update(GhosttyTerminal term);
+
+/** Get dimensions */
+int ghostty_render_state_get_cols(GhosttyTerminal term);
+int ghostty_render_state_get_rows(GhosttyTerminal term);
+
+/** Get cursor state (individual getters for WASM efficiency) */
+int ghostty_render_state_get_cursor_x(GhosttyTerminal term);
+int ghostty_render_state_get_cursor_y(GhosttyTerminal term);
+bool ghostty_render_state_get_cursor_visible(GhosttyTerminal term);
+
+/** Get default colors as 0xRRGGBB */
+uint32_t ghostty_render_state_get_bg_color(GhosttyTerminal term);
+uint32_t ghostty_render_state_get_fg_color(GhosttyTerminal term);
+
+/** Check if a row is dirty */
+bool ghostty_render_state_is_row_dirty(GhosttyTerminal term, int y);
+
+/** Mark render state as clean (call after rendering) */
+void ghostty_render_state_mark_clean(GhosttyTerminal term);
+
+/**
+ * Get ALL viewport cells in one call - the key performance optimization!
+ * Buffer must be at least (rows * cols) cells.
+ * Returns total cells written, or -1 on error.
+ */
+int ghostty_render_state_get_viewport(
+    GhosttyTerminal term,
+    GhosttyCell* out_buffer,
+    size_t buffer_size
+);
+
+/* ============================================================================
+ * Terminal Modes
+ * ========================================================================= */
+
+/** Check if alternate screen is active */
+bool ghostty_terminal_is_alternate_screen(GhosttyTerminal term);
+
+/** Check if any mouse tracking mode is enabled */
+bool ghostty_terminal_has_mouse_tracking(GhosttyTerminal term);
+
+/**
+ * Query arbitrary terminal mode by number.
+ * @param mode Mode number (e.g., 25 for cursor visibility, 2004 for bracketed paste)
+ * @param is_ansi true for ANSI modes, false for DEC modes
+ * @return true if mode is enabled
+ */
+bool ghostty_terminal_get_mode(GhosttyTerminal term, int mode, bool is_ansi);
+
+/* ============================================================================
+ * Scrollback API
+ * ========================================================================= */
+
+/** Get number of scrollback lines (history, not including active screen) */
+int ghostty_terminal_get_scrollback_length(GhosttyTerminal term);
+
+/**
+ * Get a line from the scrollback buffer.
+ * @param offset 0 = oldest line, (length-1) = most recent scrollback line
+ * @param out_buffer Buffer to write cells to
+ * @param buffer_size Size of buffer in cells (must be >= cols)
+ * @return Number of cells written, or -1 on error
+ */
+int ghostty_terminal_get_scrollback_line(
+    GhosttyTerminal term,
+    int offset,
+    GhosttyCell* out_buffer,
+    size_t buffer_size
+);
+
+/** Check if a row is a continuation from previous row (soft-wrapped) */
+bool ghostty_terminal_is_row_wrapped(GhosttyTerminal term, int y);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* GHOSTTY_VT_TERMINAL_H */
diff --git a/src/lib_vt.zig b/src/lib_vt.zig
index 03a883e20..35f6b787f 100644
--- a/src/lib_vt.zig
+++ b/src/lib_vt.zig
@@ -140,6 +140,35 @@ comptime {
         @export(&c.sgr_unknown_partial, .{ .name = "ghostty_sgr_unknown_partial" });
         @export(&c.sgr_attribute_tag, .{ .name = "ghostty_sgr_attribute_tag" });
         @export(&c.sgr_attribute_value, .{ .name = "ghostty_sgr_attribute_value" });
+        // Terminal lifecycle
+        @export(&c.terminal_new, .{ .name = "ghostty_terminal_new" });
+        @export(&c.terminal_new_with_config, .{ .name = "ghostty_terminal_new_with_config" });
+        @export(&c.terminal_free, .{ .name = "ghostty_terminal_free" });
+        @export(&c.terminal_resize, .{ .name = "ghostty_terminal_resize" });
+        @export(&c.terminal_write, .{ .name = "ghostty_terminal_write" });
+
+        // RenderState API - high-performance rendering
+        @export(&c.render_state_update, .{ .name = "ghostty_render_state_update" });
+        @export(&c.render_state_get_cols, .{ .name = "ghostty_render_state_get_cols" });
+        @export(&c.render_state_get_rows, .{ .name = "ghostty_render_state_get_rows" });
+        @export(&c.render_state_get_cursor_x, .{ .name = "ghostty_render_state_get_cursor_x" });
+        @export(&c.render_state_get_cursor_y, .{ .name = "ghostty_render_state_get_cursor_y" });
+        @export(&c.render_state_get_cursor_visible, .{ .name = "ghostty_render_state_get_cursor_visible" });
+        @export(&c.render_state_get_bg_color, .{ .name = "ghostty_render_state_get_bg_color" });
+        @export(&c.render_state_get_fg_color, .{ .name = "ghostty_render_state_get_fg_color" });
+        @export(&c.render_state_is_row_dirty, .{ .name = "ghostty_render_state_is_row_dirty" });
+        @export(&c.render_state_mark_clean, .{ .name = "ghostty_render_state_mark_clean" });
+        @export(&c.render_state_get_viewport, .{ .name = "ghostty_render_state_get_viewport" });
+
+        // Terminal modes
+        @export(&c.terminal_is_alternate_screen, .{ .name = "ghostty_terminal_is_alternate_screen" });
+        @export(&c.terminal_has_mouse_tracking, .{ .name = "ghostty_terminal_has_mouse_tracking" });
+        @export(&c.terminal_get_mode, .{ .name = "ghostty_terminal_get_mode" });
+
+        // Scrollback API
+        @export(&c.terminal_get_scrollback_length, .{ .name = "ghostty_terminal_get_scrollback_length" });
+        @export(&c.terminal_get_scrollback_line, .{ .name = "ghostty_terminal_get_scrollback_line" });
+        @export(&c.terminal_is_row_wrapped, .{ .name = "ghostty_terminal_is_row_wrapped" });
 
         // On Wasm we need to export our allocator convenience functions.
         if (builtin.target.cpu.arch.isWasm()) {
diff --git a/src/terminal/c/main.zig b/src/terminal/c/main.zig
index bc92597f5..6a97183fe 100644
--- a/src/terminal/c/main.zig
+++ b/src/terminal/c/main.zig
@@ -4,6 +4,7 @@ pub const key_event = @import("key_event.zig");
 pub const key_encode = @import("key_encode.zig");
 pub const paste = @import("paste.zig");
 pub const sgr = @import("sgr.zig");
+pub const terminal = @import("terminal.zig");
 
 // The full C API, unexported.
 pub const osc_new = osc.new;
@@ -52,6 +53,36 @@ pub const key_encoder_encode = key_encode.encode;
 
 pub const paste_is_safe = paste.is_safe;
 
+// Terminal lifecycle
+pub const terminal_new = terminal.new;
+pub const terminal_new_with_config = terminal.newWithConfig;
+pub const terminal_free = terminal.free;
+pub const terminal_resize = terminal.resize;
+pub const terminal_write = terminal.write;
+
+// RenderState API - high-performance rendering
+pub const render_state_update = terminal.renderStateUpdate;
+pub const render_state_get_cols = terminal.renderStateGetCols;
+pub const render_state_get_rows = terminal.renderStateGetRows;
+pub const render_state_get_cursor_x = terminal.renderStateGetCursorX;
+pub const render_state_get_cursor_y = terminal.renderStateGetCursorY;
+pub const render_state_get_cursor_visible = terminal.renderStateGetCursorVisible;
+pub const render_state_get_bg_color = terminal.renderStateGetBgColor;
+pub const render_state_get_fg_color = terminal.renderStateGetFgColor;
+pub const render_state_is_row_dirty = terminal.renderStateIsRowDirty;
+pub const render_state_mark_clean = terminal.renderStateMarkClean;
+pub const render_state_get_viewport = terminal.renderStateGetViewport;
+
+// Terminal modes
+pub const terminal_is_alternate_screen = terminal.isAlternateScreen;
+pub const terminal_has_mouse_tracking = terminal.hasMouseTracking;
+pub const terminal_get_mode = terminal.getMode;
+
+// Scrollback API
+pub const terminal_get_scrollback_length = terminal.getScrollbackLength;
+pub const terminal_get_scrollback_line = terminal.getScrollbackLine;
+pub const terminal_is_row_wrapped = terminal.isRowWrapped;
+
 test {
     _ = color;
     _ = osc;
@@ -59,6 +90,7 @@ test {
     _ = key_encode;
     _ = paste;
     _ = sgr;
+    _ = terminal;
 
     // We want to make sure we run the tests for the C allocator interface.
     _ = @import("../../lib/allocator.zig");
diff --git a/src/terminal/c/terminal.zig b/src/terminal/c/terminal.zig
new file mode 100644
index 000000000..3868eb17b
--- /dev/null
+++ b/src/terminal/c/terminal.zig
@@ -0,0 +1,567 @@
+//! C API wrapper for Terminal
+//!
+//! This provides a minimal, high-performance interface to Ghostty's Terminal
+//! for WASM export. The key optimization is using RenderState which provides
+//! a pre-computed snapshot of all render data in a single update call.
+//!
+//! API Design:
+//! - Lifecycle: new, free, resize, write
+//! - Rendering: render_state_update, render_state_get_viewport, etc.
+//!
+//! The RenderState approach means:
+//! - ONE call to update all state (render_state_update)
+//! - ONE call to get all cells (render_state_get_viewport)
+//! - No per-row or per-cell WASM boundary crossings!
+
+const std = @import("std");
+const Allocator = std.mem.Allocator;
+const builtin = @import("builtin");
+
+const Terminal = @import("../Terminal.zig");
+const ReadonlyStream = @import("../stream_readonly.zig").Stream;
+const render = @import("../render.zig");
+const RenderState = render.RenderState;
+const color = @import("../color.zig");
+const modespkg = @import("../modes.zig");
+const point = @import("../point.zig");
+const Style = @import("../style.zig").Style;
+
+const log = std.log.scoped(.terminal_c);
+
+/// Wrapper struct that owns the Terminal, stream, and RenderState.
+const TerminalWrapper = struct {
+    alloc: Allocator,
+    terminal: Terminal,
+    stream: ReadonlyStream,
+    render_state: RenderState,
+    /// Track alternate screen state to detect screen switches
+    last_screen_is_alternate: bool = false,
+};
+
+/// C-compatible cell structure (16 bytes)
+pub const GhosttyCell = extern struct {
+    codepoint: u32,
+    fg_r: u8,
+    fg_g: u8,
+    fg_b: u8,
+    bg_r: u8,
+    bg_g: u8,
+    bg_b: u8,
+    flags: u8,
+    width: u8,
+    hyperlink_id: u16,
+    _pad: u16 = 0,
+};
+
+/// Dirty state
+pub const GhosttyDirty = enum(u8) {
+    none = 0,
+    partial = 1,
+    full = 2,
+};
+
+/// C-compatible terminal configuration
+pub const GhosttyTerminalConfig = extern struct {
+    scrollback_limit: u32,
+    fg_color: u32,
+    bg_color: u32,
+    cursor_color: u32,
+    palette: [16]u32,
+};
+
+// ============================================================================
+// Lifecycle
+// ============================================================================
+
+pub fn new(cols: c_int, rows: c_int) callconv(.c) ?*anyopaque {
+    return newWithConfig(cols, rows, null);
+}
+
+pub fn newWithConfig(
+    cols: c_int,
+    rows: c_int,
+    config_: ?*const GhosttyTerminalConfig,
+) callconv(.c) ?*anyopaque {
+    const alloc = if (builtin.target.cpu.arch.isWasm())
+        std.heap.wasm_allocator
+    else
+        std.heap.c_allocator;
+
+    const wrapper = alloc.create(TerminalWrapper) catch return null;
+
+    // Parse config or use defaults
+    const scrollback_limit: usize = if (config_) |cfg|
+        if (cfg.scrollback_limit == 0) std.math.maxInt(usize) else cfg.scrollback_limit
+    else
+        10_000;
+
+    // Setup terminal colors
+    var colors = Terminal.Colors.default;
+    if (config_) |cfg| {
+        if (cfg.fg_color != 0) {
+            const rgb = color.RGB{
+                .r = @truncate((cfg.fg_color >> 16) & 0xFF),
+                .g = @truncate((cfg.fg_color >> 8) & 0xFF),
+                .b = @truncate(cfg.fg_color & 0xFF),
+            };
+            colors.foreground = color.DynamicRGB.init(rgb);
+        }
+        if (cfg.bg_color != 0) {
+            const rgb = color.RGB{
+                .r = @truncate((cfg.bg_color >> 16) & 0xFF),
+                .g = @truncate((cfg.bg_color >> 8) & 0xFF),
+                .b = @truncate(cfg.bg_color & 0xFF),
+            };
+            colors.background = color.DynamicRGB.init(rgb);
+        }
+        if (cfg.cursor_color != 0) {
+            const rgb = color.RGB{
+                .r = @truncate((cfg.cursor_color >> 16) & 0xFF),
+                .g = @truncate((cfg.cursor_color >> 8) & 0xFF),
+                .b = @truncate(cfg.cursor_color & 0xFF),
+            };
+            colors.cursor = color.DynamicRGB.init(rgb);
+        }
+        // Apply palette colors (0 = use default)
+        for (cfg.palette, 0..) |palette_color, i| {
+            if (palette_color != 0) {
+                const rgb = color.RGB{
+                    .r = @truncate((palette_color >> 16) & 0xFF),
+                    .g = @truncate((palette_color >> 8) & 0xFF),
+                    .b = @truncate(palette_color & 0xFF),
+                };
+                colors.palette.set(@intCast(i), rgb);
+            }
+        }
+    }
+
+    wrapper.terminal = Terminal.init(alloc, .{
+        .cols = @intCast(cols),
+        .rows = @intCast(rows),
+        .max_scrollback = scrollback_limit,
+        .colors = colors,
+    }) catch {
+        alloc.destroy(wrapper);
+        return null;
+    };
+
+    wrapper.* = .{
+        .alloc = alloc,
+        .terminal = wrapper.terminal,
+        .stream = wrapper.terminal.vtStream(),
+        .render_state = RenderState.empty,
+    };
+
+    // NOTE: linefeed mode must be FALSE to match native terminal behavior
+    // When true, LF does automatic CR which breaks apps like nvim
+    wrapper.terminal.modes.set(.linefeed, false);
+    return @ptrCast(wrapper);
+}
+
+pub fn free(ptr: ?*anyopaque) callconv(.c) void {
+    const wrapper: *TerminalWrapper = @ptrCast(@alignCast(ptr orelse return));
+    const alloc = wrapper.alloc;
+    wrapper.stream.deinit();
+    wrapper.render_state.deinit(alloc);
+    wrapper.terminal.deinit(alloc);
+    alloc.destroy(wrapper);
+}
+
+pub fn resize(ptr: ?*anyopaque, cols: c_int, rows: c_int) callconv(.c) void {
+    const wrapper: *TerminalWrapper = @ptrCast(@alignCast(ptr orelse return));
+    wrapper.terminal.resize(wrapper.alloc, @intCast(cols), @intCast(rows)) catch return;
+}
+
+pub fn write(ptr: ?*anyopaque, data: [*]const u8, len: usize) callconv(.c) void {
+    const wrapper: *TerminalWrapper = @ptrCast(@alignCast(ptr orelse return));
+    wrapper.stream.nextSlice(data[0..len]) catch return;
+}
+
+// ============================================================================
+// RenderState API - High-performance rendering
+// ============================================================================
+
+/// Update render state from terminal. Call once per frame.
+/// Returns dirty state: 0=none, 1=partial, 2=full
+pub fn renderStateUpdate(ptr: ?*anyopaque) callconv(.c) GhosttyDirty {
+    const wrapper: *TerminalWrapper = @ptrCast(@alignCast(ptr orelse return .full));
+    
+    // Detect screen buffer switch (normal <-> alternate)
+    const current_is_alternate = wrapper.terminal.screens.active_key == .alternate;
+    const screen_switched = current_is_alternate != wrapper.last_screen_is_alternate;
+    wrapper.last_screen_is_alternate = current_is_alternate;
+    
+    // When screen switches, we must fully reset the render state to avoid
+    // stale cached cell data from the previous screen buffer.
+    if (screen_switched) {
+        wrapper.render_state.deinit(wrapper.alloc);
+        wrapper.render_state = RenderState.empty;
+    }
+    
+    wrapper.render_state.update(wrapper.alloc, &wrapper.terminal) catch return .full;
+    
+    // If screen switched, always return full dirty to force complete redraw
+    if (screen_switched) {
+        return .full;
+    }
+    
+    return switch (wrapper.render_state.dirty) {
+        .false => .none,
+        .partial => .partial,
+        .full => .full,
+    };
+}
+
+/// Get dimensions from render state
+pub fn renderStateGetCols(ptr: ?*anyopaque) callconv(.c) c_int {
+    const wrapper: *const TerminalWrapper = @ptrCast(@alignCast(ptr orelse return 0));
+    return @intCast(wrapper.render_state.cols);
+}
+
+pub fn renderStateGetRows(ptr: ?*anyopaque) callconv(.c) c_int {
+    const wrapper: *const TerminalWrapper = @ptrCast(@alignCast(ptr orelse return 0));
+    return @intCast(wrapper.render_state.rows);
+}
+
+/// Get cursor X position
+pub fn renderStateGetCursorX(ptr: ?*anyopaque) callconv(.c) c_int {
+    const wrapper: *const TerminalWrapper = @ptrCast(@alignCast(ptr orelse return 0));
+    return @intCast(wrapper.render_state.cursor.active.x);
+}
+
+/// Get cursor Y position  
+pub fn renderStateGetCursorY(ptr: ?*anyopaque) callconv(.c) c_int {
+    const wrapper: *const TerminalWrapper = @ptrCast(@alignCast(ptr orelse return 0));
+    return @intCast(wrapper.render_state.cursor.active.y);
+}
+
+/// Check if cursor is visible
+pub fn renderStateGetCursorVisible(ptr: ?*anyopaque) callconv(.c) bool {
+    const wrapper: *const TerminalWrapper = @ptrCast(@alignCast(ptr orelse return false));
+    return wrapper.render_state.cursor.visible;
+}
+
+/// Get default background color as 0xRRGGBB
+pub fn renderStateGetBgColor(ptr: ?*anyopaque) callconv(.c) u32 {
+    const wrapper: *const TerminalWrapper = @ptrCast(@alignCast(ptr orelse return 0));
+    const bg = wrapper.render_state.colors.background;
+    return (@as(u32, bg.r) << 16) | (@as(u32, bg.g) << 8) | bg.b;
+}
+
+/// Get default foreground color as 0xRRGGBB
+pub fn renderStateGetFgColor(ptr: ?*anyopaque) callconv(.c) u32 {
+    const wrapper: *const TerminalWrapper = @ptrCast(@alignCast(ptr orelse return 0xCCCCCC));
+    const fg = wrapper.render_state.colors.foreground;
+    return (@as(u32, fg.r) << 16) | (@as(u32, fg.g) << 8) | fg.b;
+}
+
+/// Check if row is dirty
+pub fn renderStateIsRowDirty(ptr: ?*anyopaque, y: c_int) callconv(.c) bool {
+    const wrapper: *const TerminalWrapper = @ptrCast(@alignCast(ptr orelse return true));
+    if (wrapper.render_state.dirty == .full) return true;
+    if (wrapper.render_state.dirty == .false) return false;
+    const y_usize: usize = @intCast(y);
+    if (y_usize >= wrapper.render_state.row_data.len) return false;
+    return wrapper.render_state.row_data.items(.dirty)[y_usize];
+}
+
+/// Mark render state as clean after rendering
+pub fn renderStateMarkClean(ptr: ?*anyopaque) callconv(.c) void {
+    const wrapper: *TerminalWrapper = @ptrCast(@alignCast(ptr orelse return));
+    wrapper.render_state.dirty = .false;
+    @memset(wrapper.render_state.row_data.items(.dirty), false);
+}
+
+/// Get ALL viewport cells in one call - reads directly from terminal screen buffer.
+/// This bypasses the RenderState cache to ensure fresh data for all rows.
+/// Returns total cells written (rows * cols), or -1 on error.
+pub fn renderStateGetViewport(
+    ptr: ?*anyopaque,
+    out: [*]GhosttyCell,
+    buf_size: usize,
+) callconv(.c) c_int {
+    const wrapper: *const TerminalWrapper = @ptrCast(@alignCast(ptr orelse return -1));
+    const rs = &wrapper.render_state;
+    const t = &wrapper.terminal;
+    const rows = rs.rows;
+    const cols = rs.cols;
+    const total: usize = @as(usize, rows) * cols;
+
+    if (buf_size < total) return -1;
+
+    // Read directly from terminal's active screen, bypassing RenderState cache.
+    // This ensures we always get fresh data for ALL rows, not just dirty ones.
+    const pages = &t.screens.active.pages;
+
+    var idx: usize = 0;
+    for (0..rows) |y| {
+        // Get the row from the active viewport
+        const pin = pages.pin(.{ .active = .{ .y = @intCast(y) } }) orelse {
+            // Row doesn't exist, fill with defaults
+            for (0..cols) |_| {
+                out[idx] = .{
+                    .codepoint = 0,
+                    .fg_r = rs.colors.foreground.r,
+                    .fg_g = rs.colors.foreground.g,
+                    .fg_b = rs.colors.foreground.b,
+                    .bg_r = rs.colors.background.r,
+                    .bg_g = rs.colors.background.g,
+                    .bg_b = rs.colors.background.b,
+                    .flags = 0,
+                    .width = 1,
+                    .hyperlink_id = 0,
+                };
+                idx += 1;
+            }
+            continue;
+        };
+
+        const cells = pin.cells(.all);
+        const page = pin.node.data;
+
+        for (0..cols) |x| {
+            if (x >= cells.len) {
+                // Past end of row, fill with default
+                out[idx] = .{
+                    .codepoint = 0,
+                    .fg_r = rs.colors.foreground.r,
+                    .fg_g = rs.colors.foreground.g,
+                    .fg_b = rs.colors.foreground.b,
+                    .bg_r = rs.colors.background.r,
+                    .bg_g = rs.colors.background.g,
+                    .bg_b = rs.colors.background.b,
+                    .flags = 0,
+                    .width = 1,
+                    .hyperlink_id = 0,
+                };
+                idx += 1;
+                continue;
+            }
+
+            const cell = &cells[x];
+
+            // Get style from page styles (cell has style_id)
+            const sty: Style = if (cell.style_id > 0)
+                page.styles.get(page.memory, cell.style_id).*
+            else
+                .{};
+
+            // Resolve colors
+            const fg: color.RGB = switch (sty.fg_color) {
+                .none => rs.colors.foreground,
+                .palette => |i| rs.colors.palette[i],
+                .rgb => |rgb| rgb,
+            };
+            const bg: color.RGB = if (sty.bg(cell, &rs.colors.palette)) |rgb| rgb else rs.colors.background;
+
+            // Build flags
+            var flags: u8 = 0;
+            if (sty.flags.bold) flags |= 1 << 0;
+            if (sty.flags.italic) flags |= 1 << 1;
+            if (sty.flags.underline != .none) flags |= 1 << 2;
+            if (sty.flags.strikethrough) flags |= 1 << 3;
+            if (sty.flags.inverse) flags |= 1 << 4;
+            if (sty.flags.invisible) flags |= 1 << 5;
+            if (sty.flags.blink) flags |= 1 << 6;
+            if (sty.flags.faint) flags |= 1 << 7;
+
+            out[idx] = .{
+                .codepoint = cell.codepoint(),
+                .fg_r = fg.r,
+                .fg_g = fg.g,
+                .fg_b = fg.b,
+                .bg_r = bg.r,
+                .bg_g = bg.g,
+                .bg_b = bg.b,
+                .flags = flags,
+                .width = switch (cell.wide) {
+                    .narrow => 1,
+                    .wide => 2,
+                    .spacer_tail, .spacer_head => 0,
+                },
+                .hyperlink_id = if (cell.hyperlink) 1 else 0,
+            };
+            idx += 1;
+        }
+    }
+
+    return @intCast(total);
+}
+
+// ============================================================================
+// Terminal Modes (minimal set for compatibility)
+// ============================================================================
+
+pub fn isAlternateScreen(ptr: ?*anyopaque) callconv(.c) bool {
+    const wrapper: *const TerminalWrapper = @ptrCast(@alignCast(ptr orelse return false));
+    return wrapper.terminal.screens.active_key == .alternate;
+}
+
+pub fn hasMouseTracking(ptr: ?*anyopaque) callconv(.c) bool {
+    const wrapper: *const TerminalWrapper = @ptrCast(@alignCast(ptr orelse return false));
+    return wrapper.terminal.modes.get(.mouse_event_normal) or
+           wrapper.terminal.modes.get(.mouse_event_button) or
+           wrapper.terminal.modes.get(.mouse_event_any);
+}
+
+/// Query arbitrary terminal mode by number
+/// Returns true if mode is set, false otherwise
+pub fn getMode(ptr: ?*anyopaque, mode_num: c_int, is_ansi: bool) callconv(.c) bool {
+    const wrapper: *const TerminalWrapper = @ptrCast(@alignCast(ptr orelse return false));
+    const mode = modespkg.modeFromInt(@intCast(mode_num), is_ansi) orelse return false;
+    return wrapper.terminal.modes.get(mode);
+}
+
+// ============================================================================
+// Scrollback API
+// ============================================================================
+
+/// Get the number of scrollback lines (history, not including active screen)
+pub fn getScrollbackLength(ptr: ?*anyopaque) callconv(.c) c_int {
+    const wrapper: *const TerminalWrapper = @ptrCast(@alignCast(ptr orelse return 0));
+    const pages = &wrapper.terminal.screens.active.pages;
+    // total_rows includes both scrollback and active area
+    // We subtract rows (active area) to get just scrollback
+    if (pages.total_rows <= pages.rows) return 0;
+    return @intCast(pages.total_rows - pages.rows);
+}
+
+/// Get a line from the scrollback buffer
+/// offset 0 = oldest line in scrollback, offset (length-1) = most recent scrollback line
+/// Returns number of cells written, or -1 on error
+pub fn getScrollbackLine(
+    ptr: ?*anyopaque,
+    offset: c_int,
+    out: [*]GhosttyCell,
+    buf_size: usize,
+) callconv(.c) c_int {
+    const wrapper: *const TerminalWrapper = @ptrCast(@alignCast(ptr orelse return -1));
+    const rs = &wrapper.render_state;
+    const cols = rs.cols;
+    
+    if (buf_size < cols) return -1;
+    if (offset < 0) return -1;
+    
+    const scrollback_len = getScrollbackLength(ptr);
+    if (offset >= scrollback_len) return -1;
+    
+    // Get the pin for this scrollback row
+    // history point: y=0 is oldest, y=scrollback_len-1 is newest
+    const pages = &wrapper.terminal.screens.active.pages;
+    const pin = pages.pin(.{ .history = .{ .y = @intCast(offset) } }) orelse return -1;
+    
+    // Get cells for this row
+    const cells = pin.cells(.all);
+    const page = pin.node.data;
+    
+    // Fill output buffer
+    for (0..cols) |x| {
+        if (x >= cells.len) {
+            // Fill with default
+            out[x] = .{
+                .codepoint = 0,
+                .fg_r = rs.colors.foreground.r,
+                .fg_g = rs.colors.foreground.g,
+                .fg_b = rs.colors.foreground.b,
+                .bg_r = rs.colors.background.r,
+                .bg_g = rs.colors.background.g,
+                .bg_b = rs.colors.background.b,
+                .flags = 0,
+                .width = 1,
+                .hyperlink_id = 0,
+            };
+            continue;
+        }
+        
+        const cell = &cells[x];
+        
+        // Get style from page styles (cell has style_id)
+        const sty: Style = if (cell.style_id > 0)
+            page.styles.get(page.memory, cell.style_id).*
+        else
+            .{};
+        
+        // Resolve colors
+        const fg: color.RGB = switch (sty.fg_color) {
+            .none => rs.colors.foreground,
+            .palette => |i| rs.colors.palette[i],
+            .rgb => |rgb| rgb,
+        };
+        const bg: color.RGB = if (sty.bg(cell, &rs.colors.palette)) |rgb| rgb else rs.colors.background;
+        
+        // Build flags
+        var flags: u8 = 0;
+        if (sty.flags.bold) flags |= 1 << 0;
+        if (sty.flags.italic) flags |= 1 << 1;
+        if (sty.flags.underline != .none) flags |= 1 << 2;
+        if (sty.flags.strikethrough) flags |= 1 << 3;
+        if (sty.flags.inverse) flags |= 1 << 4;
+        if (sty.flags.invisible) flags |= 1 << 5;
+        if (sty.flags.blink) flags |= 1 << 6;
+        if (sty.flags.faint) flags |= 1 << 7;
+        
+        out[x] = .{
+            .codepoint = cell.codepoint(),
+            .fg_r = fg.r,
+            .fg_g = fg.g,
+            .fg_b = fg.b,
+            .bg_r = bg.r,
+            .bg_g = bg.g,
+            .bg_b = bg.b,
+            .flags = flags,
+            .width = switch (cell.wide) {
+                .narrow => 1,
+                .wide => 2,
+                .spacer_tail, .spacer_head => 0,
+            },
+            .hyperlink_id = if (cell.hyperlink) 1 else 0,
+        };
+    }
+    return @intCast(cols);
+}
+
+/// Check if a row is a continuation from the previous row (soft-wrapped)
+/// This matches xterm.js semantics where isWrapped indicates the row continues
+/// from the previous row, not that it wraps to the next row.
+pub fn isRowWrapped(ptr: ?*anyopaque, y: c_int) callconv(.c) bool {
+    const wrapper: *const TerminalWrapper = @ptrCast(@alignCast(ptr orelse return false));
+    const pages = &wrapper.terminal.screens.active.pages;
+    
+    // Get pin for this row in active area
+    const pin = pages.pin(.{ .active = .{ .y = @intCast(y) } }) orelse return false;
+    const rac = pin.rowAndCell();
+    
+    // wrap_continuation means this row continues from the previous row
+    return rac.row.wrap_continuation;
+}
+
+// ============================================================================
+// Tests
+// ============================================================================
+
+test "terminal lifecycle" {
+    const term = new(80, 24);
+    defer free(term);
+    try std.testing.expect(term != null);
+
+    _ = renderStateUpdate(term);
+    try std.testing.expectEqual(@as(c_int, 80), renderStateGetCols(term));
+    try std.testing.expectEqual(@as(c_int, 24), renderStateGetRows(term));
+}
+
+test "terminal write and read via render state" {
+    const term = new(80, 24);
+    defer free(term);
+
+    write(term, "Hello", 5);
+    _ = renderStateUpdate(term);
+
+    var cells: [80 * 24]GhosttyCell = undefined;
+    const count = renderStateGetViewport(term, &cells, 80 * 24);
+    try std.testing.expectEqual(@as(c_int, 80 * 24), count);
+    try std.testing.expectEqual(@as(u32, 'H'), cells[0].codepoint);
+    try std.testing.expectEqual(@as(u32, 'e'), cells[1].codepoint);
+    try std.testing.expectEqual(@as(u32, 'l'), cells[2].codepoint);
+    try std.testing.expectEqual(@as(u32, 'l'), cells[3].codepoint);
+    try std.testing.expectEqual(@as(u32, 'o'), cells[4].codepoint);
+}
diff --git a/src/terminal/render.zig b/src/terminal/render.zig
index b6430ea34..10e0ef79d 100644
--- a/src/terminal/render.zig
+++ b/src/terminal/render.zig
@@ -322,13 +322,14 @@ pub const RenderState = struct {
         // Colors.
         self.colors.cursor = t.colors.cursor.get();
         self.colors.palette = t.colors.palette.current;
-        bg_fg: {
+        {
             // Background/foreground can be unset initially which would
-            // depend on "default" background/foreground. The expected use
-            // case of Terminal is that the caller set their own configured
-            // defaults on load so this doesn't happen.
-            const bg = t.colors.background.get() orelse break :bg_fg;
-            const fg = t.colors.foreground.get() orelse break :bg_fg;
+            // depend on "default" background/foreground. Use sensible defaults
+            // (black background, light gray foreground) when not explicitly set.
+            const default_bg: color.RGB = .{ .r = 0, .g = 0, .b = 0 };
+            const default_fg: color.RGB = .{ .r = 204, .g = 204, .b = 204 };
+            const bg = t.colors.background.get() orelse default_bg;
+            const fg = t.colors.foreground.get() orelse default_fg;
             if (t.modes.get(.reverse_colors)) {
                 self.colors.background = fg;
                 self.colors.foreground = bg;
